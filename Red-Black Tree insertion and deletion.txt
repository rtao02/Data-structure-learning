
#include <iostream>
#include <conio.h>
#include<Windows.h>
using namespace std;

class node {
public:
	node* p_parent;
	node* p_Lchild;
	node* p_Rchild;
	int value;
	bool color; //true: red, false: black
	node() { p_parent = p_Lchild = p_Rchild = nullptr; }
	node(int i) { value = i; p_parent = p_Lchild = p_Rchild = nullptr; }
};

class tree {
public:
	node* root;
	tree() { root = nullptr; }

	//For insert, the new node should be the last of nodes with the same value in the order of 
	//inorder traversal.  (The same as HW5.)
	void insert_node(int i);
	void insert_R_rotate(node* p);//For insert_node, R-rotate at node pointed by p
	void insert_L_rotate(node* p);//for insert_node, L-rotate at node pointed by p
	//All other siutions of insert_node should be directly implemented inside add_node


	//For delete, the deleted node shoud be the first of nodes with the same value in the order of
	//inorder traversal. (The same as HW5).
	//For replacement, always recursively replace it with predecessor, unless there is no predecessor. (In this
	//case, replace it with sucessor.)


	void delete_node(int i);
	void delete_1(node* p); //case 1 of delete_node; p points to the parent of double black node
	void delete_1_R_rotate(node* p);//R_totate used in case 1 of delete_node; p points to the parent of double black node
	void delete_1_L_rotate(node* p);//L_totate used in case 1 of delete_node; p points to the parent of double black node
	void delete_2A(node* p); //case 2A of delete_node; p points to the parent of double black node
	void delete_2B(node* p);//case 2B of delete_node; p points to the parent of double black node
	void delete_3(node* p);//case 3 of delete_node; p points to the parent of double black node
	//All other cases of delete_node should be directly implemented inside the delete_node.

	//For the following, during traveral, print (value, color) of each node.
	void InorderPrint(node*);
	void PostorderPrint(node*);
	void PreorderPrint(node*);
};

void tree::delete_3(node* p) {
	int LSubTreeH = 1;
	int RSubTreeH = 1;
	node* curLeftH = p->p_Lchild;
	node* curRightH = p->p_Rchild;
	while (curLeftH != nullptr) {
		if (curLeftH->color == 0) {
			LSubTreeH++;
		}
		curLeftH = curLeftH->p_Lchild;
	}
	while (curRightH != nullptr) {
		if (curRightH->color == 0) {
			RSubTreeH++;
		}
		curRightH = curRightH->p_Rchild;
	}
	if (LSubTreeH > RSubTreeH) {
		node* sibling = p->p_Lchild;
		if (p->p_Lchild->p_Rchild == nullptr) {
			p->color = 1;
			p->p_Lchild->color = 0;
			if (p == root) {
				root = sibling;
				sibling->p_parent = nullptr;
				sibling->p_Rchild = p;
				p->p_parent = sibling;
				p->p_Lchild = nullptr;
			}
			else if (&*p == &*p->p_parent->p_Rchild) {
				node* parent = p->p_parent;
				parent->p_Rchild = sibling;
				sibling->p_parent = parent;
				p->p_parent = sibling;
				sibling->p_Rchild = p;
				p->p_Lchild = nullptr;
			}
			else if (&*p == &*p->p_parent->p_Lchild) {
				node* parent = p->p_parent;
				parent->p_Lchild = sibling;
				sibling->p_parent = parent;
				p->p_parent = sibling;
				sibling->p_Rchild = p;
				p->p_Lchild = nullptr;
			}
		}
		else if (p->p_Lchild->p_Rchild != nullptr) {
			p->color = 1;
			p->p_Lchild->color = 0;
			node* temp = p->p_Lchild->p_Rchild;
			//temp->color = 1;
			if (p == root) {
				root = sibling;
				sibling->p_parent = nullptr;
				sibling->p_Rchild = p;
				p->p_parent = sibling;
				p->p_Lchild = temp;
				temp->p_parent = p;
			}
			else if (&*p == &*p->p_parent->p_Rchild) {
				node* parent = p->p_parent;
				parent->p_Rchild = sibling;
				sibling->p_parent = parent;
				p->p_parent = sibling;
				sibling->p_Rchild = p;
				p->p_Lchild = temp;
				temp->p_parent = p;
			}
			else if (&*p == &*p->p_parent->p_Lchild) {
				node* parent = p->p_parent;
				parent->p_Lchild = sibling;
				sibling->p_parent = parent;
				p->p_parent = sibling;
				sibling->p_Rchild = p;
				p->p_Lchild = temp;
				temp->p_parent = p;
			}
		}
	}
	else if (LSubTreeH < RSubTreeH) {
		node* sibling = p->p_Rchild;
		if (p->p_Rchild->p_Lchild == nullptr) {
			p->color = 1;
			p->p_Rchild->color = 0;
			if (p == root) {
				root = sibling;
				sibling->p_parent = nullptr;
				sibling->p_Lchild = p;
				p->p_parent = sibling;
				p->p_Rchild = nullptr;
			}
			else if (&*p == &*p->p_parent->p_Rchild) {
				node* parent = p->p_parent;
				parent->p_Rchild = sibling;
				sibling->p_parent = parent;
				p->p_parent = sibling;
				sibling->p_Lchild = p;
				p->p_Rchild = nullptr;
			}
			else if (&*p == &*p->p_parent->p_Lchild) {
				node* parent = p->p_parent;
				parent->p_Lchild = sibling;
				sibling->p_parent = parent;
				p->p_parent = sibling;
				sibling->p_Lchild = p;
				p->p_Rchild = nullptr;
			}
		}
		else if (p->p_Rchild->p_Lchild != nullptr) {
			p->color = 1;
			p->p_Rchild->color = 0;
			node* temp = p->p_Rchild->p_Lchild;
			//temp->color = 1;
			if (p == root) {
				root = sibling;
				sibling->p_parent = nullptr;
				sibling->p_Lchild = p;
				p->p_parent = sibling;
				p->p_Rchild = temp;
				temp->p_parent = p;
			}
			else if (&*p == &*p->p_parent->p_Rchild) {
				node* parent = p->p_parent;
				parent->p_Rchild = sibling;
				sibling->p_parent = parent;
				p->p_parent = sibling;
				sibling->p_Lchild = p;
				p->p_Rchild = temp;
				temp->p_parent = p;
			}
			else if (&*p == &*p->p_parent->p_Lchild) {
				node* parent = p->p_parent;
				parent->p_Lchild = sibling;
				sibling->p_parent = parent;
				p->p_parent = sibling;
				sibling->p_Lchild = p;
				p->p_Rchild = temp;
				temp->p_parent = p;
			}
		}
	}
	else if (LSubTreeH == RSubTreeH) {
		cout << "Should not enter case 3, go to check delete_3!!!" << endl;
	}
}

void tree::delete_2B(node* p) {
	if (p->p_Lchild == nullptr || p->p_Rchild == nullptr) {
		if (p->p_Lchild == nullptr) {
			p->p_Rchild->color = 1;
			p->color = 0;
		}
		else if (p->p_Rchild == nullptr) {
			p->p_Lchild->color = 1;
			p->color = 0;
		}
	}
	else if (p->p_Lchild != nullptr && p->p_Rchild != nullptr) {
		p->color = 0;
		int LSubTreeH = 1;
		int RSubTreeH = 1;
		node* curLeft = p->p_Lchild;
		node* curRight = p->p_Rchild;
		while (curLeft != nullptr) {
			if (curLeft->color == 0) {
				LSubTreeH++;
			}
			curLeft = curLeft->p_Lchild;
		}
		while (curRight != nullptr) {
			if (curRight->color == 0) {
				RSubTreeH++;
			}
			curRight = curRight->p_Rchild;
		}
		if (LSubTreeH > RSubTreeH) {
			p->p_Lchild->color = 1;
		}
		else if (LSubTreeH < RSubTreeH) {
			p->p_Rchild->color = 1;
		}
		else if (LSubTreeH == RSubTreeH) {
			cout << "should not show this case, check delete_2B." << endl;
		}
		/*if (p->p_Lchild->p_Lchild != nullptr) {
			if (p->p_Lchild->p_Lchild->color == 1) {
				p->p_Rchild->color = 1;
			}
		}
		else if (p->p_Lchild->p_Rchild != nullptr) {
			if (p->p_Lchild->p_Rchild->color == 1) {
				p->p_Rchild->color = 1;
			}
		}
		else if (p->p_Rchild->p_Lchild != nullptr) {
			if (p->p_Rchild->p_Lchild->color == 1) {
				p->p_Lchild->color = 1;
			}
		}
		else if (p->p_Rchild->p_Rchild != nullptr) {
			if (p->p_Rchild->p_Rchild->color == 1) {
				p->p_Lchild->color = 1;
			}
		}*/
	}
}

void tree::delete_2A(node* p) {
	if (p->p_Lchild == nullptr || p->p_Rchild == nullptr) {
		if (p->p_Lchild == nullptr) {
			p->p_Rchild->color = 1;
		}
		else if (p->p_Rchild == nullptr) {
			p->p_Lchild->color = 1;
		}
	}
	else if (p->p_Lchild != nullptr && p->p_Rchild != nullptr) {
		if (p->p_Lchild->p_Lchild != nullptr) {
			if (p->p_Lchild->p_Lchild->color == 1) {
				p->p_Rchild->color = 1;
			}
		}
		else if (p->p_Lchild->p_Rchild != nullptr) {
			if (p->p_Lchild->p_Rchild->color == 1) {
				p->p_Rchild->color = 1;
			}
		}
		else if (p->p_Rchild->p_Lchild != nullptr) {
			if (p->p_Rchild->p_Lchild->color == 1) {
				p->p_Lchild->color = 1;
			}
		}
		else if (p->p_Rchild->p_Rchild != nullptr) {
			if (p->p_Rchild->p_Rchild->color == 1) {
				p->p_Lchild->color = 1;
			}
		}
	}
}

void tree::delete_1_R_rotate(node* p) {
	bool keepedColor = p->color;
	node* sibling = p->p_Lchild;
	sibling->color = keepedColor;
	sibling->p_Lchild->color = 0;
	p->color = 0;
	if (p->p_Lchild->p_Rchild == nullptr) {
		if (p->p_parent == nullptr) {//p is root
			root = sibling;
			sibling->p_parent = nullptr;
			p->p_parent = sibling;
			sibling->p_Rchild = p;
			p->p_Lchild = nullptr;
		}
		else if (p->p_parent != nullptr) {
			if (&*p == &*p->p_parent->p_Lchild) {//p is the left child of his parent
				node* parent = p->p_parent;
				parent->p_Lchild = sibling;
				sibling->p_parent = parent;
				p->p_parent = sibling;
				sibling->p_Rchild = p;
				p->p_Lchild = nullptr;
			}
			else if (&*p == &*p->p_parent->p_Rchild) {//p is the right child of his parent
				node* parent = p->p_parent;
				parent->p_Rchild = sibling;
				sibling->p_parent = parent;
				sibling->p_Rchild = p;
				p->p_parent = sibling;
				p->p_Lchild = nullptr;
			}
		}
	}
	else if (p->p_Lchild->p_Rchild != nullptr) {
		node* temp = p->p_Lchild->p_Rchild;
		if (p->p_parent == nullptr) {//p is root
			root = sibling;
			sibling->p_parent = nullptr;
			p->p_parent = sibling;
			sibling->p_Rchild = p;
			p->p_Lchild = temp;
			temp->p_parent = p;
		}
		else if (p->p_parent != nullptr) {
			if (&*p == &*p->p_parent->p_Lchild) {//p is the left child of his parent
				node* parent = p->p_parent;
				parent->p_Lchild = sibling;
				sibling->p_parent = parent;
				p->p_parent = sibling;
				sibling->p_Rchild = p;
				p->p_Lchild = temp;
				temp->p_parent = p;
			}
			else if (&*p == &*p->p_parent->p_Rchild) {//p is the right child of his parent
				node* parent = p->p_parent;
				parent->p_Rchild = sibling;
				sibling->p_parent = parent;
				sibling->p_Rchild = p;
				p->p_parent = sibling;
				p->p_Lchild = temp;
				temp->p_parent = p;
			}
		}
	}
}

void tree::delete_1_L_rotate(node* p) {
	bool keepedColor = p->color;
	node* sibling = p->p_Rchild;
	sibling->color = keepedColor;
	sibling->p_Rchild->color = 0;
	p->color = 0;
	if (p->p_Rchild->p_Lchild == nullptr) {
		if (p->p_parent == nullptr) {//p is root
			root = sibling;
			sibling->p_parent = nullptr;
			sibling->p_Lchild = p;
			p->p_parent = sibling;
			p->p_Rchild = nullptr;
		}
		else if (p->p_parent != nullptr) {
			if (&*p == &*p->p_parent->p_Lchild) {//p is the L child of his parent
				node* parent = p->p_parent;
				parent->p_Lchild = sibling;
				sibling->p_parent = parent;
				sibling->p_Lchild = p;
				p->p_parent = sibling;
				p->p_Rchild = nullptr;
			}
			else if (&*p == &*p->p_parent->p_Rchild) {//p is the R child of his parent
				node* parent = p->p_parent;
				parent->p_Rchild = sibling;
				sibling->p_parent = parent;
				p->p_parent = sibling;
				sibling->p_Lchild = p;
				p->p_Rchild = nullptr;
			}
		}
	}
	else if (p->p_Rchild->p_Lchild != nullptr) {
		if (p->p_parent == nullptr) {//p is root
			node* temp = sibling->p_Lchild;
			root = sibling;
			sibling->p_parent = nullptr;
			sibling->p_Lchild = p;
			p->p_parent = sibling;
			p->p_Rchild = temp;
			temp->p_parent = p;
		}
		else if (p->p_parent != nullptr) {
			if (&*p == &*p->p_parent->p_Lchild) {//p is the L child of his parent
				node* parent = p->p_parent;
				node* temp = sibling->p_Lchild;
				parent->p_Lchild = sibling;
				sibling->p_parent = parent;
				sibling->p_Lchild = p;
				p->p_parent = sibling;
				p->p_Rchild = temp;
				temp->p_parent = p;
			}
			else if (&*p == &*p->p_parent->p_Rchild) {//p is the R child of his parent
				node* parent = p->p_parent;
				node* temp = sibling->p_Lchild;
				parent->p_Rchild = sibling;
				sibling->p_parent = parent;
				p->p_parent = sibling;
				sibling->p_Lchild = p;
				p->p_Rchild = temp;
				temp->p_parent = p;
			}
		}
	}
}

void tree::delete_1(node* p) {//could have LL LR RR RL
	//determine the rotate pattern
	if (p->p_Lchild == nullptr) {
		if (p->p_Rchild->p_Rchild != nullptr) {
			if (p->p_Rchild->p_Rchild->color == 1) {//RR
				delete_1_L_rotate(p);
			}
		}
		else if (p->p_Rchild->p_Lchild != nullptr) {
			if (p->p_Rchild->p_Lchild->color == 1) {//RL
				//do R rotate at sibling
				p->p_Rchild->color = 1;
				p->p_Rchild->p_Lchild->color = 0;
				node* sibling = p->p_Rchild;
				p->p_Rchild = sibling->p_Lchild;
				sibling->p_Lchild->p_parent = p;
				sibling->p_parent = sibling->p_Lchild;
				sibling->p_Lchild->p_Rchild = sibling;
				sibling->p_Lchild = nullptr;
				delete_1_L_rotate(p);
			}
		}
	}
	else if (p->p_Rchild == nullptr) {
		if (p->p_Lchild->p_Lchild != nullptr) {
			if (p->p_Lchild->p_Lchild->color == 1) {//LL
				delete_1_R_rotate(p);
			}
		}
		else if (p->p_Lchild->p_Rchild != nullptr) {
			if (p->p_Lchild->p_Rchild->color == 1) {//LR
				//do L rotate at sibling
				node* sibling = p->p_Lchild;
				sibling->color = 1;
				sibling->p_Lchild->color = 0;
				p->p_Lchild = sibling->p_Rchild;
				sibling->p_Rchild->p_parent = p;
				sibling->p_parent = sibling->p_Rchild;
				sibling->p_Rchild->p_Lchild = sibling;
				sibling->p_Rchild = nullptr;
				delete_1_R_rotate(p);
			}
		}
	}
	else if (p->p_Lchild != nullptr && p->p_Rchild != nullptr) {
		int LSubTreeH = 1;
		int RSubTreeH = 1;
		node* curLeftH = p->p_Lchild;
		node* curRightH = p->p_Rchild;
		while (curLeftH != nullptr) {
			if (curLeftH->color == 0) {
				LSubTreeH++;
			}
			curLeftH = curLeftH->p_Lchild;
		}
		while (curRightH != nullptr) {
			if (curRightH->color == 0) {
				RSubTreeH++;
			}
			curRightH = curRightH->p_Rchild;
		}
		if (LSubTreeH > RSubTreeH) {
			if (p->p_Lchild->p_Lchild != nullptr) {
				if (p->p_Lchild->p_Lchild->color == 1) {//LL
					delete_1_R_rotate(p);
				}
			}
			else if (p->p_Lchild->p_Rchild != nullptr) {
				if (p->p_Lchild->p_Rchild->color == 1) {//LR
					//do L rotate at sibling
					node* sibling = p->p_Lchild;
					sibling->color = 1;
					sibling->p_Lchild->color = 0;
					p->p_Lchild = sibling->p_Rchild;
					sibling->p_Rchild->p_parent = p;
					sibling->p_parent = sibling->p_Rchild;
					sibling->p_Rchild->p_Lchild = sibling;
					sibling->p_Rchild = nullptr;
					delete_1_R_rotate(p);
				}
			}
		}
		else if (LSubTreeH < RSubTreeH) {
			if (p->p_Rchild->p_Rchild != nullptr) {
				if (p->p_Rchild->p_Rchild->color == 1) {//RR
					delete_1_L_rotate(p);
				}
			}
			else if (p->p_Rchild->p_Lchild != nullptr) {
				if (p->p_Rchild->p_Lchild->color == 1) {//RL
					//do R rotate at sibling
					p->p_Rchild->color = 1;
					p->p_Rchild->p_Lchild->color = 0;
					node* sibling = p->p_Rchild;
					p->p_Rchild = sibling->p_Lchild;
					sibling->p_Lchild->p_parent = p;
					sibling->p_parent = sibling->p_Lchild;
					sibling->p_Lchild->p_Rchild = sibling;
					sibling->p_Lchild = nullptr;
					delete_1_L_rotate(p);
				}
			}
		}
		else if (LSubTreeH == RSubTreeH) {
			cout << "It shouldn't enter case 1, go to check delete_1." << endl;
		}
	}
}

void tree::delete_node(int i) {
	node* deleteN = nullptr;
	if (root == nullptr) return;//empty tree -> return
	else {
		//find the deleted node
		node* cur = root;
		while (cur) {
			//left is null then check the node and go to right
			if (cur->p_Lchild == nullptr) {
				if (cur->value == i && deleteN == nullptr) deleteN = cur;//here we found delete node
				/*if (cur->color == 1) {
					cout << "(" << cur->value << ", ";
					SetConsoleTextAttribute(hConsole, 4);
					cout << "Red";
					SetConsoleTextAttribute(hConsole, 7);
					cout << ")";
				}
				else {
					cout << "(" << cur->value << ", Black)";
				}*/
				cur = cur->p_Rchild;
			}
			else {
				//find the predecessor
				node* pre = cur->p_Lchild;
				//for finding the predecessor we need to go left first and go right till the end or current node
				while (pre->p_Rchild != cur && pre->p_Rchild != nullptr) {
					pre = pre->p_Rchild;
				}//after this step we found the predecessor
				//if predecessor's right child is nullptr means we didn't check this one for now, and then link it with current node
				if (pre->p_Rchild == nullptr) {
					pre->p_Rchild = cur;
					cur = cur->p_Lchild;
				}
				else {//left is already visit, Go right after visiting current
					pre->p_Rchild = nullptr;
					if (cur->value == i && deleteN == nullptr) deleteN = cur;//here we found delete node
					/*if (cur->color == 1) {
						cout << "(" << cur->value << ", ";
						SetConsoleTextAttribute(hConsole, 4);
						cout << "Red";
						SetConsoleTextAttribute(hConsole, 7);
						cout << ")";
					}
					else {
						cout << "(" << cur->value << ", Black)";
					}*/
					cur = cur->p_Rchild;
				}
			}
		}
		//Here, we find the delete node or nothing
		if (deleteN == nullptr) {//Didn't find deleted node 
			cout << "No such node need be deleted." << endl;
			return;
		}
		else {//have such node -> recursively replace delete node with precessor -> delete -> fix propagable violation
			while (deleteN->p_Lchild != nullptr || deleteN->p_Rchild != nullptr) {//keep loop while deleted node is not a leaf node
				node* findPredecessor = deleteN->p_Lchild;
				node* predecessor = deleteN;

				node* findSuccessor = deleteN->p_Rchild;
				node* successor = deleteN;
				//find successor
				while (findPredecessor != nullptr) {
					predecessor = findPredecessor;
					findPredecessor = findPredecessor->p_Rchild;
				}
				//find successor
				while (findSuccessor != nullptr) {
					successor = findSuccessor;
					findSuccessor = findSuccessor->p_Lchild;
				}
				//1. find predecessor; 2. no predecessor 
				if (&*predecessor != &*deleteN) {//find the predecessor
					//replace 2 node(delete node and predecessor) and set new deleteN
					int tempValue = deleteN->value;
					//bool tempColor = deleteN->color;
					deleteN->value = predecessor->value;
					//deleteN->color = predecessor->color;
					predecessor->value = tempValue;
					//predecessor->color = tempColor;
					deleteN = predecessor;
				}
				else if (&*predecessor == &*deleteN && &*successor != &*deleteN) {//the address of pointer predecessor is same as pointer delete node's address.(NOT FIND PREDECESSOR)
					//replace 2 node(delete node and successor) and set new deleteN
					int tempValue = deleteN->value;
					//bool tempColor = deleteN->color;
					deleteN->value = successor->value;
					//deleteN->color = successor->color;
					successor->value = tempValue;
					//successor->color = tempColor;
					deleteN = successor;
				}
				//&*predecessor == &*deleteN && &*successor == &*deleteN(already the leaf node)
			}
			//delete current delete node
			if (deleteN->color == 1) {//delete node is red node just delete it 
				if (deleteN == root) {//only root node for check
					root = nullptr;
					delete deleteN;
					cout << "if you see this info means that only node(root)'s color was wrong! go to check delete part." << endl;
				}
				else {
					if (&*deleteN == &*deleteN->p_parent->p_Lchild) {//delete node is the left child of his parent
						deleteN->p_parent->p_Lchild = nullptr;
						delete deleteN;
					}
					else if (&*deleteN == &*deleteN->p_parent->p_Rchild) {//delete node is the right child of his parent
						deleteN->p_parent->p_Rchild = nullptr;
						delete deleteN;
					}
				}
			}
			else {//delete node's color is black -> fix upcoming violation(red black tree's black leaf node have sibling definitely)
				node* actionN = nullptr;
				if (deleteN == root) {//only root node for check
					root = nullptr;
					delete deleteN;
				}
				else {//delete node is not the root node
					//determine the delete case
					node* doubleBlackN = deleteN;
					label1:
					int afterDCase = 0;
					//case 1: sibling of double black node is balck and it has at least one red child
						//case 11 RR; case 12 RL; case 13 LL; case 14 LR;
					//case 2A: sibling of double black node is balck and it has no red child; parent is black
					//case 2B: sibling of double black node is black and it has no red child; parent is red
					//case 3: sibling of double black node is red.
					if (&*doubleBlackN == &*doubleBlackN->p_parent->p_Lchild) {//delete node is the left child of his parent
						if (doubleBlackN->p_parent->p_Rchild->color == 0) {//sibling is black
							if (doubleBlackN->p_parent->p_Rchild->p_Lchild == nullptr && doubleBlackN->p_parent->p_Rchild->p_Rchild == nullptr) {//sibling's have no child
								if (doubleBlackN->p_parent->color == 0) {//parent's color is black
									afterDCase = 21;//case 2A
									actionN = doubleBlackN->p_parent;
								}
								else if (doubleBlackN->p_parent->color == 1) {
									afterDCase = 22;//case 2B
									actionN = doubleBlackN->p_parent;
								}
							}
							else if (doubleBlackN->p_parent->p_Rchild->p_Lchild == nullptr && doubleBlackN->p_parent->p_Rchild->p_Rchild != nullptr) {//sibling's have one null child
								if (doubleBlackN->p_parent->color == 0 && doubleBlackN->p_parent->p_Rchild->p_Rchild->color == 0) {
									afterDCase = 21;//case 2A
									actionN = doubleBlackN->p_parent;
								}
								else if (doubleBlackN->p_parent->color == 1 && doubleBlackN->p_parent->p_Rchild->p_Rchild->color == 0) {
									afterDCase = 22;//case 2B
									actionN = doubleBlackN->p_parent;
								}
								else if (doubleBlackN->p_parent->p_Rchild->p_Rchild->color == 1) {//sibling have one red child
									afterDCase = 1;//case 1 RR parttern
									actionN = doubleBlackN->p_parent;
								}
							}
							else if (doubleBlackN->p_parent->p_Rchild->p_Lchild != nullptr && doubleBlackN->p_parent->p_Rchild->p_Rchild == nullptr) {//sibling's have one null child
								if (doubleBlackN->p_parent->color == 0 && doubleBlackN->p_parent->p_Rchild->p_Lchild->color == 0) {
									afterDCase = 21;//case 2A
									actionN = doubleBlackN->p_parent;
								}
								else if (doubleBlackN->p_parent->color == 1 && doubleBlackN->p_parent->p_Rchild->p_Lchild->color == 0) {
									afterDCase = 22;//case 2B
									actionN = doubleBlackN->p_parent;
								}
								else if (doubleBlackN->p_parent->p_Rchild->p_Lchild->color == 1) {//sibling have one red child
									afterDCase = 1;//case 1 RL parttern
									actionN = doubleBlackN->p_parent;
								}
							}
							else if (doubleBlackN->p_parent->p_Rchild->p_Lchild != nullptr && doubleBlackN->p_parent->p_Rchild->p_Rchild != nullptr) {//sibling's have TWO child
								if (doubleBlackN->p_parent->color == 0 && doubleBlackN->p_parent->p_Rchild->p_Lchild->color == 0 && doubleBlackN->p_parent->p_Rchild->p_Rchild->color == 0) {
									afterDCase = 21;//case 2A
									actionN = doubleBlackN->p_parent;
								}
								else if (doubleBlackN->p_parent->color == 1 && doubleBlackN->p_parent->p_Rchild->p_Lchild->color == 0 && doubleBlackN->p_parent->p_Rchild->p_Rchild->color == 0) {
									afterDCase = 22;//case 2B
									actionN = doubleBlackN->p_parent;
								}
								else if (doubleBlackN->p_parent->p_Rchild->p_Lchild->color == 1 || doubleBlackN->p_parent->p_Rchild->p_Rchild->color == 1) {//sibling have two red children
									afterDCase = 1;//case 1 RL parttern or RR parttern
									actionN = doubleBlackN->p_parent;
									//if (doubleBlackN->p_parent->p_Rchild->p_Rchild->color == 1) {
									//	afterDCase = 11;//case 1 RR pattern
									//}
									//else if (doubleBlackN->p_parent->p_Rchild->p_Lchild->color == 1) {
									//	afterDCase = 12;//case 1 RL pattern
									//}
								}
							}
						}
						else {//sibling's color is red
							afterDCase = 3;//case 3
							actionN = doubleBlackN->p_parent;
						}
					}
					else if (&*doubleBlackN == &*doubleBlackN->p_parent->p_Rchild) {//delete node is the right child of his parent
						if (doubleBlackN->p_parent->p_Lchild->color == 0) {//sibling is black
							if (doubleBlackN->p_parent->p_Lchild->p_Lchild == nullptr && doubleBlackN->p_parent->p_Lchild->p_Rchild == nullptr) {//sibling's have no child
								if (doubleBlackN->p_parent->color == 0) {//parent's color is black
									afterDCase = 21;//case 2A
									actionN = doubleBlackN->p_parent;
								}
								else if (doubleBlackN->p_parent->color == 1) {
									afterDCase = 22;//case 2B
									actionN = doubleBlackN->p_parent;
								}
							}
							else if (doubleBlackN->p_parent->p_Lchild->p_Lchild == nullptr && doubleBlackN->p_parent->p_Lchild->p_Rchild != nullptr) {//sibling's have one null child
								if (doubleBlackN->p_parent->color == 0 && doubleBlackN->p_parent->p_Lchild->p_Rchild->color == 0) {
									afterDCase = 21;//case 2A
									actionN = doubleBlackN->p_parent;
								}
								else if (doubleBlackN->p_parent->color == 1 && doubleBlackN->p_parent->p_Lchild->p_Rchild->color == 0) {
									afterDCase = 22;//case 2B
									actionN = doubleBlackN->p_parent;
								}
								else if (doubleBlackN->p_parent->p_Lchild->p_Rchild->color == 1) {//sibling have one red child
									afterDCase = 1;//case 1 LR parttern
									actionN = doubleBlackN->p_parent;
								}
							}
							else if (doubleBlackN->p_parent->p_Lchild->p_Lchild != nullptr && doubleBlackN->p_parent->p_Lchild->p_Rchild == nullptr) {//sibling's have one null child
								if (doubleBlackN->p_parent->color == 0 && doubleBlackN->p_parent->p_Lchild->p_Lchild->color == 0) {
									afterDCase = 21;//case 2A
									actionN = doubleBlackN->p_parent;
								}
								else if (doubleBlackN->p_parent->color == 1 && doubleBlackN->p_parent->p_Lchild->p_Lchild->color == 0) {
									afterDCase = 22;//case 2B
									actionN = doubleBlackN->p_parent;
								}
								else if (doubleBlackN->p_parent->p_Lchild->p_Lchild->color == 1) {//sibling have one red child
									afterDCase = 1;//case 1 LL parttern
									actionN = doubleBlackN->p_parent;
								}
							}
							else if (doubleBlackN->p_parent->p_Lchild->p_Lchild != nullptr && doubleBlackN->p_parent->p_Lchild->p_Rchild != nullptr) {//sibling's have TWO child
								if (doubleBlackN->p_parent->color == 0 && doubleBlackN->p_parent->p_Lchild->p_Lchild->color == 0 && doubleBlackN->p_parent->p_Lchild->p_Rchild->color == 0) {
									afterDCase = 21;//case 2A
									actionN = doubleBlackN->p_parent;
								}
								else if (doubleBlackN->p_parent->color == 1 && doubleBlackN->p_parent->p_Lchild->p_Lchild->color == 0 && doubleBlackN->p_parent->p_Lchild->p_Rchild->color == 0) {
									afterDCase = 22;//case 2B
									actionN = doubleBlackN->p_parent;
								}
								else if (doubleBlackN->p_parent->p_Lchild->p_Lchild->color == 1 || doubleBlackN->p_parent->p_Lchild->p_Rchild->color == 1) {//sibling have two red children
									afterDCase = 1;//case 1 LL parttern or LR parttern
									actionN = doubleBlackN->p_parent;
									//if (doubleBlackN->p_parent->p_Lchild->p_Lchild->color == 1) {
									//	afterDCase = 13;//case 1 LL pattern
									//}
									//else if (doubleBlackN->p_parent->p_Lchild->p_Rchild->color == 1) {
									//	afterDCase = 14;//case 1 LR pattern
									//}
								}
							}
						}
						else {//sibling's color is red
							afterDCase = 3;//case 3
							actionN = doubleBlackN->p_parent;
						}
					}
					//delete deleteN
					if (deleteN != nullptr) {
						if (&*deleteN == &*deleteN->p_parent->p_Lchild) {
							deleteN->p_parent->p_Lchild = nullptr;
							if (deleteN->p_Lchild == nullptr && deleteN->p_Rchild == nullptr) {//for check
								cout << "delete BLACK node have no children.Correct!!!" << endl;
							}
							delete deleteN;
							deleteN = nullptr;
						}
						else if (&*deleteN == &*deleteN->p_parent->p_Rchild) {
							deleteN->p_parent->p_Rchild = nullptr;
							if (deleteN->p_Lchild == nullptr && deleteN->p_Rchild == nullptr) {//for check
								cout << "delete BLACK node have no children.Correct!!!" << endl;
							}
							delete deleteN;
							deleteN = nullptr;
						}
					}
					
					//for now we have determined the case 1 2A 2B 3 already
					//then fix it
					if (afterDCase == 1) {//case 1
						delete_1(actionN);
					}
					else if (afterDCase == 21) {//case 2A
						delete_2A(actionN);
						doubleBlackN = actionN;
						goto label1;
					}
					else if (afterDCase == 22) {//case 2B
						delete_2B(actionN);
					}
					else if (afterDCase == 3) {//case 3
						delete_3(actionN);
						int LSubTreeH = 1;
						int RSubTreeH = 1;
						node* curLeft = actionN->p_Lchild;
						node* curRight = actionN->p_Rchild;
						while (curLeft != nullptr) {
							if (curLeft->color == 0) {
								LSubTreeH++;
							}
							curLeft = curLeft->p_Lchild;
						}
						while (curRight != nullptr) {
							if (curRight->color == 0) {
								RSubTreeH++;
							}
							curRight = curRight->p_Lchild;
						}
						if (LSubTreeH > RSubTreeH) {
							doubleBlackN = actionN->p_Rchild;
							goto label1;
						}
						else if (LSubTreeH < RSubTreeH) {
							doubleBlackN = actionN->p_Lchild;
							goto label1;
						}
						else if (LSubTreeH == RSubTreeH) {
							cout << "case 3 should not fix the violation directly, Height of left and right subtree may not be same. checkcheck." << endl;
						}
					}
				}
			}
		}
	}
}

void tree::insert_L_rotate(node* p) {
	////for check
	//if (p->color == 0 && p->p_Rchild->color == 1) cout << "Indeed need L rotate." << endl;
	////check end
	if (p->color == 0) {//p's color is balck
		if (p == root && p->p_Rchild->p_Lchild == nullptr) {
			root->color = 1;
			root = root->p_Rchild;
			root->color = 0;
			root->p_Lchild = p;
			p->p_parent = root;
			root->p_parent = nullptr;
			p->p_Rchild = nullptr;
		}
		else if (p == root && p->p_Rchild->p_Lchild != nullptr) {
			node* temp = p->p_Rchild->p_Lchild;
			root->color = 1;
			root = root->p_Rchild;
			root->color = 0;
			root->p_Lchild = p;
			p->p_parent = root;
			root->p_parent = nullptr;
			p->p_Rchild = temp;
			temp->p_parent = p;
		}
		else if (p != root && p->p_Rchild->p_Lchild == nullptr) {
			p->color = 1;
			p->p_Rchild->color = 0;
			if (&*p == &*p->p_parent->p_Lchild) {//p is left child of his parent
				p->p_parent->p_Lchild = p->p_Rchild;
				p->p_Rchild->p_parent = p->p_parent;
				p->p_parent = p->p_Rchild;
				p->p_Rchild->p_Lchild = p;
				p->p_Rchild = nullptr;
			}
			else if (&*p == &*p->p_parent->p_Rchild) {//p is the right child of his parent
				p->p_parent->p_Rchild = p->p_Rchild;
				p->p_Rchild->p_parent = p->p_parent;
				p->p_parent = p->p_Rchild;
				p->p_Rchild->p_Lchild = p;
				p->p_Rchild = nullptr;
			}
		}
		else if (p != root && p->p_Rchild->p_Lchild != nullptr) {
			p->color = 1;
			p->p_Rchild->color = 0;
			node* temp = p->p_Rchild->p_Lchild;
			if (&*p == &*p->p_parent->p_Lchild) {//p is left child of his parent
				p->p_parent->p_Lchild = p->p_Rchild;
				p->p_Rchild->p_parent = p->p_parent;
				p->p_parent = p->p_Rchild;
				p->p_Rchild->p_Lchild = p;
				p->p_Rchild = temp;
				temp->p_parent = p;

			}
			else if (&*p == &*p->p_parent->p_Rchild) {//p is the right child of his parent
				p->p_parent->p_Rchild = p->p_Rchild;
				p->p_Rchild->p_parent = p->p_parent;
				p->p_parent = p->p_Rchild;
				p->p_Rchild->p_Lchild = p;
				p->p_Rchild = temp;
				temp->p_parent = p;
			}
		}
	}
	else {//p's color is red
		if (&*p == &*p->p_parent->p_Lchild) {//p is the left child of his parent
			p->p_parent->p_Lchild = p->p_Rchild;
			p->p_Rchild->p_parent = p->p_parent;
			p->p_parent = p->p_Rchild;
			p->p_Rchild->p_Lchild = p;
			p->p_Rchild = nullptr;
		}
		else if (&*p == &*p->p_parent->p_Rchild) {//p is the right child of his parent
			cout << "if you see this info go to check the L rotate for red node." << endl;
		}
	}
	
}

void tree::insert_R_rotate(node* p) {
	////for check
	//if (p->color == 0 && p->p_Lchild->color == 1) cout << "Indeed need R rotate." << endl;
	////check end
	if (p->color == 0) {//p's color is balck
		if (p == root && p->p_Lchild->p_Rchild == nullptr) {
			p->color = 1;
			p->p_Lchild->color = 0;
			root = p->p_Lchild;
			root->p_Rchild = p;
			p->p_parent = root;
			root->p_parent = nullptr;
			p->p_Lchild = nullptr;
		}
		else if (p == root && p->p_Lchild->p_Rchild != nullptr) {
			node* temp = root->p_Lchild->p_Rchild;
			p->color = 1;
			p->p_Lchild->color = 0;
			root = p->p_Lchild;
			root->p_parent = nullptr;
			root->p_Rchild = p;
			p->p_parent = root;
			p->p_Lchild = temp;
			temp->p_parent = p;
		}
		else if (p != root && p->p_Lchild->p_Rchild == nullptr) {
			p->color = 1;
			p->p_Lchild->color = 0;
			if (&*p == &*p->p_parent->p_Lchild) {//p is the left child of his parent
				p->p_parent->p_Lchild = p->p_Lchild;
				p->p_Lchild->p_parent = p->p_parent;
				p->p_parent = p->p_Lchild;
				p->p_Lchild->p_Rchild = p;
				p->p_Lchild = nullptr;
			}
			else if (&*p == &*p->p_parent->p_Rchild) {//p us the right child of his parent
				p->p_parent->p_Rchild = p->p_Lchild;
				p->p_Lchild->p_parent = p->p_parent;
				p->p_parent = p->p_Lchild;
				p->p_Lchild->p_Rchild = p;
				p->p_Lchild = nullptr;
			}
			
		}
		else if (p != root && p->p_Lchild->p_Rchild != nullptr) {
			node* temp = p->p_Lchild->p_Rchild;
			p->color = 1;
			p->p_Lchild->color = 0;
			if (&*p == &*p->p_parent->p_Lchild) {//p is the left child of his parent
				p->p_parent->p_Lchild = p->p_Lchild;
				p->p_Lchild->p_parent = p->p_parent;
				p->p_parent = p->p_Lchild;
				p->p_Lchild->p_Rchild = p;
				p->p_Lchild = temp;
				temp->p_parent = p;
			}
			else if (&*p == &*p->p_parent->p_Rchild) {//p us the right child of his parent
				p->p_parent->p_Rchild = p->p_Lchild;
				p->p_Lchild->p_parent = p->p_parent;
				p->p_parent = p->p_Lchild;
				p->p_Lchild->p_Rchild = p;
				p->p_Lchild = temp;
				temp->p_parent = p;
			}
			
		}
	}
	else {//p's color is red
		if (&*p == &*p->p_parent->p_Lchild) {//p is the left child of his parent
			cout << "if you see this info, check the insert R rotate for red node." << endl;
		}
		else if(&*p == &*p->p_parent->p_Rchild) {//p is the right child of his parent
			p->p_parent->p_Rchild = p->p_Lchild;
			p->p_Lchild->p_parent = p->p_parent;
			p->p_parent = p->p_Lchild;
			p->p_Lchild = nullptr;
			p->p_parent->p_Rchild = p;
		}
	}
	
}

void tree::insert_node(int i) {
	node* curNode = new node(i);
	if (root == nullptr) {//for a empty tree
		curNode->color = 0;
		root = curNode;
		return;//confirm the root then insert finished
	}
	else {//connect new node
		//find the position for insert
		curNode->color = 1;
		node* pos = root;
		node* poschild = root;
		int label = 0;//label == 1 means left, label == 2 means right
		while (poschild != nullptr) {//find the position for attaching new node
			if (i < poschild->value) {
				pos = poschild;
				poschild = poschild->p_Lchild;
				label = 1;
			}
			else {//i >= poschild->value
				pos = poschild;
				poschild = poschild->p_Rchild;
				label = 2;
			}
		}
		//for check dose the pos whether right or not
		if (label == 1 && pos->p_Lchild == nullptr) cout << "T" << endl;
		else if (label == 2 && pos->p_Rchild == nullptr) cout << "T" << endl;
		else cout << "F" << endl;
		if (label == 1) {
			pos->p_Lchild = curNode;
			curNode->p_parent = pos;
		}
		else if (label == 2) {
			pos->p_Rchild = curNode;
			curNode->p_parent = pos;
		}
		label1:
		//check violation and determine its type
		int vioType;
		node* actionN = root;
		if (curNode->p_parent->color == 0) {//we new inserted node's parent is black, means there no violation -> finish!
			vioType = 0;
			actionN = nullptr;
			return;
		}
		else if (curNode->p_parent->color == 1) {//we have two red node adjacent
			//cout << &*curNode << endl;
			//cout << &*curNode->p_parent->p_Rchild << endl;
			if (&*curNode == &*curNode->p_parent->p_Lchild) {//current node is the left child of his parent
				if (&*curNode->p_parent == &*curNode->p_parent->p_parent->p_Lchild) {//cur's parent is the left child of his parent
					//means that is LL patern
					if (curNode->p_parent->p_parent->p_Rchild == nullptr) {//uncle is NIL(ALSO BLACK)
						vioType = 10;//LL patern and uncle is black
						actionN = curNode->p_parent->p_parent;
					}
					else if (curNode->p_parent->p_parent->p_Rchild->color == 0) {//uncle is black
						vioType = 10;//LL patern and uncle is black
						actionN = curNode->p_parent->p_parent;
					}
					else if (curNode->p_parent->p_parent->p_Rchild->color == 1) {//uncle is red
						vioType = 11;//LL patern and uncle is red
						actionN = curNode->p_parent;//change this node's color to black
					}
				}
				else if (&*curNode->p_parent == &*curNode->p_parent->p_parent->p_Rchild) {//cur's parent is the right of his parent
					//means that is RL patern
					if (curNode->p_parent->p_parent->p_Lchild == nullptr) {//uncle is NIL(ALSO BLACK)
						vioType = 20;//RL patern and uncle is black
						actionN = curNode->p_parent->p_parent;
					}
					else if (curNode->p_parent->p_parent->p_Lchild->color == 0) {//uncle is black or NIL
						vioType = 20;//RL patern and uncle is black
						actionN = curNode->p_parent->p_parent;
					}
					else if (curNode->p_parent->p_parent->p_Lchild->color == 1) {//uncle is red
						vioType = 21;//RL pattern and uncle is red
						actionN = curNode->p_parent;//change this node's color to black
					}
				}
			}
			else if (&*curNode == &*curNode->p_parent->p_Rchild) {//means current node is the right child of his parent
				if (&*curNode->p_parent == &*curNode->p_parent->p_parent->p_Lchild) {//cur's parent is the left child of his parent
					//means that is LR patern
					if (curNode->p_parent->p_parent->p_Rchild == nullptr) {//undle is NIL(ALSO BLACK)
						vioType = 30;//LR patern and uncle is black
						actionN = curNode->p_parent->p_parent;
					}
					else if (curNode->p_parent->p_parent->p_Rchild->color == 0) {//uncle is black
						vioType = 30;//LR patern and uncle is black
						actionN = curNode->p_parent->p_parent;
					}
					else if (curNode->p_parent->p_parent->p_Rchild->color == 1) {//uncle is red
						vioType = 31;//LR patern and uncle is red
						actionN = curNode->p_parent;//change this node's color to black
					}
				}
				else if (&*curNode->p_parent == &*curNode->p_parent->p_parent->p_Rchild) {//cur's parent is the right of his parent
					//means that is RR patern
					if (curNode->p_parent->p_parent->p_Lchild == nullptr) {//uncle is NIL(ALSO BLACK)
						vioType = 40;//RR patern and uncle is black
						actionN = curNode->p_parent->p_parent;
					}
					else if (curNode->p_parent->p_parent->p_Lchild->color == 0) {//uncle is black
						vioType = 40;//RR patern and uncle is black
						actionN = curNode->p_parent->p_parent;
					}
					else if (curNode->p_parent->p_parent->p_Lchild->color == 1){//uncle is red
						vioType = 41;//RR pattern and uncle is red
						actionN = curNode->p_parent;//change this node's color to black
					}
				}
			}
		}
		//fix the violation
		if (vioType == 10) {//LL patern and uncle is black
			insert_R_rotate(actionN);
		}
		else if (vioType == 11) {//LL patern and uncle is red
			actionN->color = 0;
			if (actionN->p_parent->p_Rchild != nullptr) {
				actionN->p_parent->p_Rchild->color = 0;
			}
			if (actionN->p_parent != root) {
				actionN->p_parent->color = 1;
				curNode = actionN->p_parent;
				goto label1;
			}
		}
		else if (vioType == 20) {//RL patern and uncle is black
			insert_R_rotate(actionN->p_Rchild);
			insert_L_rotate(actionN);
		}
		else if (vioType == 21) {//RL pattern and uncle is red
			actionN->color = 0;
			if (actionN->p_parent->p_Lchild != nullptr) {
				actionN->p_parent->p_Lchild->color = 0;
			}
			if (actionN->p_parent != root) {
				actionN->p_parent->color = 1;
				curNode = actionN->p_parent;
				goto label1;
			}
		}
		else if (vioType == 30) {//LR patern and uncle is black
			insert_L_rotate(actionN->p_Lchild);
			insert_R_rotate(actionN);
		}
		else if (vioType == 31) {//LR patern and uncle is red
			actionN->color = 0;
			if(actionN->p_parent->p_Rchild != nullptr){
				actionN->p_parent->p_Rchild->color = 0;
			}
			if (actionN->p_parent != root) {
				actionN->p_parent->color = 1;
				curNode = actionN->p_parent;
				goto label1;
			}
		}
		else if (vioType == 40) {//RR patern and uncle is black
			insert_L_rotate(actionN);
		}
		else if (vioType == 41) {//RR pattern and uncle is red
			actionN->color = 0;
			if (actionN->p_parent->p_Lchild != nullptr) {
				actionN->p_parent->p_Lchild->color = 0;
			}
			if (actionN->p_parent != root) {
				actionN->p_parent->color = 1;
				curNode = actionN->p_parent;
				goto label1;
			}
		}
	}
	root->color = 0;
}

void tree::InorderPrint(node* p) {//p should be the root of tree
	HANDLE hConsole;
	hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
	node* cur = p;
	while (cur) {
		//left is null then check the node and go to right
		if (cur->p_Lchild == nullptr) {
			//if (cur->value == i && curdelete == nullptr) curdelete = cur;//here we found delete node
			if (cur->color == 1) {
				cout << "(" << cur->value << ", ";
				SetConsoleTextAttribute(hConsole, 4);
				cout << "Red";
				SetConsoleTextAttribute(hConsole, 7);
				cout << ")";
			}
			else {
				cout << "(" << cur->value << ", Black)";
			}
			cur = cur->p_Rchild;
		}
		else {
			//find the predecessor
			node* pre = cur->p_Lchild;
			//for finding the predecessor we need to go left first and go right till the end or current node
			while (pre->p_Rchild != cur && pre->p_Rchild != nullptr) {
				pre = pre->p_Rchild;
			}//after this step we found the predecessor
			//if predecessor's right child is nullptr means we didn't check this one for now, and then link it with current node
			if (pre->p_Rchild == nullptr) {
				pre->p_Rchild = cur;
				cur = cur->p_Lchild;
			}
			else {//left is already visit, Go right after visiting current
				pre->p_Rchild = nullptr;
				//if (cur->value == i && curdelete == nullptr) curdelete = cur;//here we found delete node
				if (cur->color == 1) {
					cout << "(" << cur->value << ", ";
					SetConsoleTextAttribute(hConsole, 4);
					cout << "Red";
					SetConsoleTextAttribute(hConsole, 7);
					cout << ")";
				}
				else {
					cout << "(" << cur->value << ", Black)";
				}
				cur = cur->p_Rchild;
			}
		}
	}
}

void tree::PostorderPrint(node* p) {//p should be the root of tree
	HANDLE hConsole;
	hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
	if (p == nullptr) return;
	PostorderPrint(p->p_Lchild);
	PostorderPrint(p->p_Rchild);
	if (p->color == 1) {
		cout << "(" << p->value << ", ";
		SetConsoleTextAttribute(hConsole, 4);
		cout << "Red";
		SetConsoleTextAttribute(hConsole, 7);
		cout << ")";
	}
	else {
		cout << "(" << p->value << ", Black)";
	}
	//node* cur = p;
	//while (cur) {
	//	//right is null the check the node and go to left
	//	if (cur->p_Rchild == nullptr) {
	//		if (cur->color == 1) {
	//			cout << "(" << cur->value << ", Red)";
	//		}
	//		else {
	//			cout << "(" << cur->value << ", Black)";
	//		}
	//		cur = cur->p_Lchild;
	//	}
	//	else {
	//		//find the successor
	//		node* suc = cur->p_Rchild;
	//		//for finding the successor we need to go right first and go left till the end or current node
	//		while (suc->p_Lchild != cur && suc->p_Lchild != nullptr) {
	//			suc = suc->p_Lchild;
	//		}//after this step we found the successor
	//		//if successor's left child is nullptr means we didn't check this one for now, and then link it with current node
	//		if (suc->p_Lchild == nullptr) {
	//			suc->p_Lchild = cur;
	//			//cout << cur->value;
	//			cur = cur->p_Rchild;
	//		}
	//		else {//right have already visited, Go left after visiting current
	//			suc->p_Lchild = nullptr;
	//			if (cur->color == 1) {
	//				cout << "(" << cur->value << ", Red)";
	//			}
	//			else {
	//				cout << "(" << cur->value << ", Black)";
	//			}
	//			cur = cur->p_Lchild;
	//		}
	//	}
	//}
}

void tree::PreorderPrint(node* p) {//p should be the root of tree
	HANDLE hConsole;
	hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
	node* cur = p;
	while (cur) {
		//left is null then check the node and go to right
		if (cur->p_Lchild == nullptr) {
			//if (cur->value == i && curdelete == nullptr) curdelete = cur;//here we found delete node
			if (cur->color == 1) {
				cout << "(" << cur->value << ", ";
				SetConsoleTextAttribute(hConsole, 4);
				cout << "Red";
				SetConsoleTextAttribute(hConsole, 7);
				cout << ")";
			}
			else {
				cout << "(" << cur->value << ", Black)";
			}
			cur = cur->p_Rchild;
		}
		else {
			//find the predecessor
			node* pre = cur->p_Lchild;
			//for finding the predecessor we need to go left first and go right till the end or current node
			while (pre->p_Rchild != cur && pre->p_Rchild != nullptr) {
				pre = pre->p_Rchild;
			}//after this step we found the predecessor
			//if predecessor's right child is nullptr means we didn't check this one for now, and then link it with current node
			if (pre->p_Rchild == nullptr) {
				pre->p_Rchild = cur;
				if (cur->color == 1) {
					cout << "(" << cur->value << ", ";
					SetConsoleTextAttribute(hConsole, 4);
					cout << "Red";
					SetConsoleTextAttribute(hConsole, 7);
					cout << ")";
				}
				else {
					cout << "(" << cur->value << ", Black)";
				}
				cur = cur->p_Lchild;
			}
			else {//left is already visit, Go right after visiting current
				pre->p_Rchild = nullptr;
				//if (cur->value == i && curdelete == nullptr) curdelete = cur;//here we found delete node

				cur = cur->p_Rchild;
			}
		}
	}
}
int main() {
	tree t1;
	//testcase1
	//root
	t1.root = new node(100);
	//level 2 
	t1.root->p_Lchild = new node(50);
	t1.root->p_Lchild->p_parent = t1.root;
	t1.root->p_Lchild->color = 1;
	t1.root->p_Rchild = new node(200);
	t1.root->p_Rchild->p_parent = t1.root;
	t1.root->p_Rchild->color = 0;
	//level 3
	t1.root->p_Lchild->p_Lchild = new node(30);
	t1.root->p_Lchild->p_Rchild = new node(70);
	t1.root->p_Lchild->p_Lchild->p_parent = t1.root->p_Lchild;
	t1.root->p_Lchild->p_Rchild->p_parent  = t1.root->p_Lchild;
	
	t1.root->p_Rchild->p_Lchild = new node(150);
	//t1.root->p_Rchild->p_Lchild->color = 1;
	t1.root->p_Rchild->p_Rchild = new node(300);
	t1.root->p_Rchild->p_Lchild->p_parent = t1.root->p_Rchild;
	t1.root->p_Rchild->p_Rchild->p_parent = t1.root->p_Rchild;
	//level 4
	t1.root->p_Lchild->p_Lchild->p_Lchild = new node(20);
	t1.root->p_Lchild->p_Lchild->p_Lchild->color = 1;
	t1.root->p_Lchild->p_Lchild->p_Rchild = new node(40);
	t1.root->p_Lchild->p_Lchild->p_Lchild->p_parent = t1.root->p_Lchild->p_Lchild;
	t1.root->p_Lchild->p_Lchild->p_Rchild->p_parent = t1.root->p_Lchild->p_Lchild;
	
	t1.root->p_Lchild->p_Rchild->p_Lchild = new node(60);
	t1.root->p_Lchild->p_Rchild->p_Rchild = new node(80);
	t1.root->p_Lchild->p_Rchild->p_Lchild->p_parent = t1.root->p_Lchild->p_Rchild;
	t1.root->p_Lchild->p_Rchild->p_Rchild->p_parent = t1.root->p_Lchild->p_Rchild;
	
	t1.root->p_Rchild->p_Lchild->p_Lchild = new node(120);
	t1.root->p_Rchild->p_Lchild->p_Rchild = new node(180);
	t1.root->p_Rchild->p_Lchild->p_Lchild->p_parent = t1.root->p_Rchild->p_Lchild;
	t1.root->p_Rchild->p_Lchild->p_Rchild->p_parent = t1.root->p_Rchild->p_Lchild;

	t1.root->p_Rchild->p_Rchild->p_Lchild = new node(250);
	t1.root->p_Rchild->p_Rchild->p_Rchild = new node(400);
	t1.root->p_Rchild->p_Rchild->p_Lchild->p_parent = t1.root->p_Rchild->p_Rchild;
	t1.root->p_Rchild->p_Rchild->p_Rchild->p_parent = t1.root->p_Rchild->p_Rchild;
	//level 5
	t1.root->p_Lchild->p_Lchild->p_Lchild->p_Lchild = new node(10);
	t1.root->p_Lchild->p_Lchild->p_Lchild->p_Rchild = new node(25);
	t1.root->p_Lchild->p_Lchild->p_Lchild->p_Lchild->p_parent = t1.root->p_Lchild->p_Lchild->p_Lchild;
	t1.root->p_Lchild->p_Lchild->p_Lchild->p_Rchild->p_parent = t1.root->p_Lchild->p_Lchild->p_Lchild;

	t1.root->p_Lchild->p_Lchild->p_Rchild->p_Lchild = new node(35);
	t1.root->p_Lchild->p_Lchild->p_Rchild->p_Rchild = new node(45);
	t1.root->p_Lchild->p_Lchild->p_Rchild->p_Lchild->p_parent = t1.root->p_Lchild->p_Lchild->p_Rchild;
	t1.root->p_Lchild->p_Lchild->p_Rchild->p_Rchild->p_parent = t1.root->p_Lchild->p_Lchild->p_Rchild;

	t1.root->p_Lchild->p_Rchild->p_Lchild->p_Lchild = new node(55);
	t1.root->p_Lchild->p_Rchild->p_Lchild->p_Rchild = new node(65);
	t1.root->p_Lchild->p_Rchild->p_Lchild->p_Lchild->p_parent = t1.root->p_Lchild->p_Rchild->p_Lchild;
	t1.root->p_Lchild->p_Rchild->p_Lchild->p_Rchild->p_parent = t1.root->p_Lchild->p_Rchild->p_Lchild;

	t1.root->p_Lchild->p_Rchild->p_Rchild->p_Lchild = new node(75);
	t1.root->p_Lchild->p_Rchild->p_Rchild->p_Rchild = new node(90);
	t1.root->p_Lchild->p_Rchild->p_Rchild->p_Lchild->p_parent = t1.root->p_Lchild->p_Rchild->p_Rchild;
	t1.root->p_Lchild->p_Rchild->p_Rchild->p_Rchild->p_parent = t1.root->p_Lchild->p_Rchild->p_Rchild;

	t1.root->p_Lchild->p_Lchild->p_Lchild->p_Lchild->p_Lchild = new node(5);
	t1.root->p_Lchild->p_Lchild->p_Lchild->p_Lchild->p_Rchild = new node(12);
	t1.root->p_Lchild->p_Lchild->p_Lchild->p_Lchild->p_Lchild->p_parent = t1.root->p_Lchild->p_Lchild->p_Lchild->p_Lchild;
	t1.root->p_Lchild->p_Lchild->p_Lchild->p_Lchild->p_Rchild->p_parent = t1.root->p_Lchild->p_Lchild->p_Lchild->p_Lchild;

	t1.root->p_Lchild->p_Lchild->p_Lchild->p_Rchild->p_Lchild = new node(23);
	t1.root->p_Lchild->p_Lchild->p_Lchild->p_Rchild->p_Rchild = new node(28);
	t1.root->p_Lchild->p_Lchild->p_Lchild->p_Rchild->p_Lchild->p_parent = t1.root->p_Lchild->p_Lchild->p_Lchild->p_Rchild;
	t1.root->p_Lchild->p_Lchild->p_Lchild->p_Rchild->p_Rchild->p_parent = t1.root->p_Lchild->p_Lchild->p_Lchild->p_Rchild;


	t1.InorderPrint(t1.root);
	t1.delete_node(200);
	cout << endl;
	t1.InorderPrint(t1.root);
	cout << endl;
	t1.PostorderPrint(t1.root);
	cout << endl;
	t1.PreorderPrint(t1.root);

	//test case 2
	////root
	//t1.root = new node(100);
	////level 2 
	//t1.root->p_Lchild = new node(50);
	//t1.root->p_Lchild->p_parent = t1.root;
	//t1.root->p_Lchild->color = 1;
	//t1.root->p_Rchild = new node(200);
	//t1.root->p_Rchild->p_parent = t1.root;
	//t1.root->p_Rchild->color = 0;
	////level 3
	//t1.root->p_Lchild->p_Lchild = new node(30);
	//t1.root->p_Lchild->p_Rchild = new node(80);
	//t1.root->p_Lchild->p_Lchild->p_parent = t1.root->p_Lchild;
	//t1.root->p_Lchild->p_Rchild->p_parent = t1.root->p_Lchild;

	//t1.root->p_Rchild->p_Lchild = new node(150);
	//t1.root->p_Rchild->p_Lchild->color = 1;
	//t1.root->p_Rchild->p_Rchild = new node(300);
	//t1.root->p_Rchild->p_Lchild->p_parent = t1.root->p_Rchild;
	//t1.root->p_Rchild->p_Rchild->p_parent = t1.root->p_Rchild;
	////level 4
	//t1.root->p_Lchild->p_Lchild->p_Lchild = new node(20);
	//t1.root->p_Lchild->p_Lchild->p_Lchild->color = 1;
	//t1.root->p_Lchild->p_Lchild->p_Rchild = new node(40);
	//t1.root->p_Lchild->p_Lchild->p_Lchild->p_parent = t1.root->p_Lchild->p_Lchild;
	//t1.root->p_Lchild->p_Lchild->p_Rchild->p_parent = t1.root->p_Lchild->p_Lchild;

	//t1.root->p_Lchild->p_Rchild->p_Lchild = new node(60);
	//t1.root->p_Lchild->p_Rchild->p_Rchild = new node(90);
	//t1.root->p_Lchild->p_Rchild->p_Lchild->p_parent = t1.root->p_Lchild->p_Rchild;
	//t1.root->p_Lchild->p_Rchild->p_Rchild->p_parent = t1.root->p_Lchild->p_Rchild;

	//t1.root->p_Rchild->p_Lchild->p_Lchild = new node(120);
	//t1.root->p_Rchild->p_Lchild->p_Rchild = new node(180);
	//t1.root->p_Rchild->p_Lchild->p_Lchild->p_parent = t1.root->p_Rchild->p_Lchild;
	//t1.root->p_Rchild->p_Lchild->p_Rchild->p_parent = t1.root->p_Rchild->p_Lchild;
	////level 5
	//t1.root->p_Lchild->p_Lchild->p_Lchild->p_Lchild = new node(10);
	//t1.root->p_Lchild->p_Lchild->p_Lchild->p_Rchild = new node(25);
	//t1.root->p_Lchild->p_Lchild->p_Lchild->p_Lchild->p_parent = t1.root->p_Lchild->p_Lchild->p_Lchild;
	//t1.root->p_Lchild->p_Lchild->p_Lchild->p_Rchild->p_parent = t1.root->p_Lchild->p_Lchild->p_Lchild;
	

	//testcase 3 
	/*t1.insert_node(8);
	t1.InorderPrint(t1.root);
	t1.insert_node(5);
	t1.InorderPrint(t1.root);
	t1.insert_node(11);
	t1.InorderPrint(t1.root);
	t1.insert_node(10);
	t1.InorderPrint(t1.root);
	t1.insert_node(9);
	t1.InorderPrint(t1.root);
	t1.insert_node(10);
	t1.InorderPrint(t1.root);
	t1.insert_node(10);
	t1.InorderPrint(t1.root);
	t1.insert_node(14);
	t1.InorderPrint(t1.root);
	t1.insert_node(12);
	t1.InorderPrint(t1.root);
	t1.insert_node(15);
	t1.InorderPrint(t1.root);
	t1.insert_node(16);
	t1.InorderPrint(t1.root);
	t1.insert_node(14);
	t1.InorderPrint(t1.root);
	t1.insert_node(14);
	t1.InorderPrint(t1.root);
	t1.insert_node(14);
	t1.InorderPrint(t1.root);
	t1.delete_node(10);
	t1.InorderPrint(t1.root);
	t1.delete_node(11);
	t1.InorderPrint(t1.root);
	cout << endl;
	t1.delete_node(8);
	t1.InorderPrint(t1.root);*/
}
